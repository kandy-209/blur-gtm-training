// Example production database implementation using Supabase
// Copy this file to db-production.ts and configure with your Supabase credentials

import { createClient } from '@supabase/supabase-js';
import type { UserResponse, TechnicalQuestion, ResponseAnalytics } from './db';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Missing Supabase environment variables');
}

const supabase = createClient(supabaseUrl, supabaseKey);

export class ProductionDatabase {
  // User Responses
  async saveUserResponse(response: Omit<UserResponse, 'id' | 'timestamp'>): Promise<UserResponse> {
    const id = `resp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const fullResponse: UserResponse = {
      ...response,
      id,
      timestamp: new Date(),
    };

    const { error } = await supabase
      .from('user_responses')
      .insert({
        id: fullResponse.id,
        user_id: fullResponse.userId,
        scenario_id: fullResponse.scenarioId,
        turn_number: fullResponse.turnNumber,
        objection_category: fullResponse.objectionCategory,
        user_message: fullResponse.userMessage,
        ai_response: fullResponse.aiResponse,
        evaluation: fullResponse.evaluation,
        confidence_score: fullResponse.confidenceScore,
        key_points_mentioned: fullResponse.keyPointsMentioned,
        created_at: fullResponse.timestamp.toISOString(),
      });

    if (error) {
      console.error('Error saving user response:', error);
      throw error;
    }

    return fullResponse;
  }

  async getUserResponses(filters?: {
    userId?: string;
    scenarioId?: string;
    objectionCategory?: string;
    limit?: number;
  }): Promise<UserResponse[]> {
    let query = supabase
      .from('user_responses')
      .select('*')
      .order('created_at', { ascending: false });

    if (filters?.userId) {
      query = query.eq('user_id', filters.userId);
    }
    if (filters?.scenarioId) {
      query = query.eq('scenario_id', filters.scenarioId);
    }
    if (filters?.objectionCategory) {
      query = query.eq('objection_category', filters.objectionCategory);
    }
    if (filters?.limit) {
      query = query.limit(filters.limit);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Error fetching user responses:', error);
      throw error;
    }

    return (data || []).map((row: any) => ({
      id: row.id,
      userId: row.user_id,
      scenarioId: row.scenario_id,
      turnNumber: row.turn_number,
      objectionCategory: row.objection_category,
      userMessage: row.user_message,
      aiResponse: row.ai_response,
      evaluation: row.evaluation,
      confidenceScore: row.confidence_score,
      timestamp: new Date(row.created_at),
      keyPointsMentioned: row.key_points_mentioned || [],
    }));
  }

  async getTopResponses(options: {
    scenarioId?: string;
    objectionCategory?: string;
    minScore?: number;
    limit?: number;
  }): Promise<ResponseAnalytics[]> {
    // Use Supabase RPC function or implement aggregation in application
    // For now, fetch all and aggregate in memory (not ideal for large datasets)
    const responses = await this.getUserResponses({
      scenarioId: options.scenarioId,
      objectionCategory: options.objectionCategory,
      limit: 1000, // Adjust based on your needs
    });

    // Filter by minScore
    let filtered = options.minScore !== undefined
      ? responses.filter(r => r.confidenceScore >= options.minScore!)
      : responses;

    // Group by normalized response text
    const responseGroups = new Map<string, UserResponse[]>();
    filtered.forEach(response => {
      const normalized = response.userMessage.toLowerCase().trim();
      if (!responseGroups.has(normalized)) {
        responseGroups.set(normalized, []);
      }
      responseGroups.get(normalized)!.push(response);
    });

    // Calculate analytics
    const analytics: ResponseAnalytics[] = Array.from(responseGroups.entries()).map(([text, group]) => {
      const totalCount = group.length;
      const successfulCount = group.filter(r => r.evaluation === 'PASS').length;
      const averageScore = group.reduce((sum, r) => sum + r.confidenceScore, 0) / totalCount;
      const successRate = (successfulCount / totalCount) * 100;

      const canonicalResponse = group.sort((a, b) => 
        b.timestamp.getTime() - a.timestamp.getTime()
      )[0];

      return {
        response: canonicalResponse.userMessage,
        count: totalCount,
        averageScore: Math.round(averageScore),
        successRate: Math.round(successRate * 10) / 10,
        scenarioId: canonicalResponse.scenarioId,
        objectionCategory: canonicalResponse.objectionCategory,
      };
    });

    analytics.sort((a, b) => {
      if (b.count !== a.count) return b.count - a.count;
      return b.successRate - a.successRate;
    });

    return options.limit ? analytics.slice(0, options.limit) : analytics;
  }

  // Technical Questions
  async saveTechnicalQuestion(question: Omit<TechnicalQuestion, 'id' | 'timestamp' | 'upvotes'>): Promise<TechnicalQuestion> {
    const id = `q_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const fullQuestion: TechnicalQuestion = {
      ...question,
      id,
      timestamp: new Date(),
      upvotes: 0,
    };

    const { error } = await supabase
      .from('technical_questions')
      .insert({
        id: fullQuestion.id,
        user_id: fullQuestion.userId,
        scenario_id: fullQuestion.scenarioId,
        question: fullQuestion.question,
        category: fullQuestion.category,
        upvotes: fullQuestion.upvotes,
        created_at: fullQuestion.timestamp.toISOString(),
      });

    if (error) {
      console.error('Error saving technical question:', error);
      throw error;
    }

    return fullQuestion;
  }

  async getTechnicalQuestions(filters?: {
    scenarioId?: string;
    category?: string;
    limit?: number;
  }): Promise<TechnicalQuestion[]> {
    let query = supabase
      .from('technical_questions')
      .select('*')
      .order('upvotes', { ascending: false })
      .order('created_at', { ascending: false });

    if (filters?.scenarioId) {
      query = query.eq('scenario_id', filters.scenarioId);
    }
    if (filters?.category) {
      query = query.eq('category', filters.category);
    }
    if (filters?.limit) {
      query = query.limit(filters.limit);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Error fetching technical questions:', error);
      throw error;
    }

    return (data || []).map((row: any) => ({
      id: row.id,
      userId: row.user_id,
      scenarioId: row.scenario_id,
      question: row.question,
      category: row.category,
      timestamp: new Date(row.created_at),
      upvotes: row.upvotes,
    }));
  }

  async upvoteQuestion(questionId: string): Promise<TechnicalQuestion | null> {
    const { data: question, error: fetchError } = await supabase
      .from('technical_questions')
      .select('*')
      .eq('id', questionId)
      .single();

    if (fetchError || !question) {
      return null;
    }

    const { error } = await supabase
      .from('technical_questions')
      .update({ upvotes: question.upvotes + 1 })
      .eq('id', questionId);

    if (error) {
      console.error('Error upvoting question:', error);
      throw error;
    }

    return {
      id: question.id,
      userId: question.user_id,
      scenarioId: question.scenario_id,
      question: question.question,
      category: question.category,
      timestamp: new Date(question.created_at),
      upvotes: question.upvotes + 1,
    };
  }

  async extractTechnicalQuestions(responseId: string): Promise<void> {
    const response = await this.getUserResponses({ limit: 1000 });
    const found = response.find(r => r.id === responseId);
    if (!found) return;

    const questionPattern = /[^.!?]*\?/g;
    const matches = found.userMessage.match(questionPattern);
    
    if (matches && matches.length > 0) {
      for (const match of matches) {
        const trimmed = match.trim();
        if (trimmed.length > 10 && trimmed.length < 500) {
          const technicalKeywords = ['how', 'what', 'why', 'when', 'where', 'does', 'can', 'will', 'api', 'integration', 'security', 'performance', 'scalability', 'deployment', 'configuration'];
          const isTechnical = technicalKeywords.some(keyword => 
            trimmed.toLowerCase().includes(keyword)
          );

          if (isTechnical) {
            await this.saveTechnicalQuestion({
              userId: found.userId,
              scenarioId: found.scenarioId,
              question: trimmed,
              category: found.objectionCategory,
            });
          }
        }
      }
    }
  }

  async getAIInsights(scenarioId: string, objectionCategory: string): Promise<{
    topResponses: ResponseAnalytics[];
    commonQuestions: TechnicalQuestion[];
    averageScore: number;
    successRate: number;
  }> {
    const responses = await this.getUserResponses({ scenarioId, objectionCategory });
    const topResponses = await this.getTopResponses({ 
      scenarioId, 
      objectionCategory,
      minScore: 80,
      limit: 10 
    });
    const commonQuestions = await this.getTechnicalQuestions({ 
      scenarioId,
      category: objectionCategory,
      limit: 10 
    });

    const averageScore = responses.length > 0
      ? responses.reduce((sum, r) => sum + r.confidenceScore, 0) / responses.length
      : 0;

    const successRate = responses.length > 0
      ? (responses.filter(r => r.evaluation === 'PASS').length / responses.length) * 100
      : 0;

    return {
      topResponses,
      commonQuestions,
      averageScore: Math.round(averageScore),
      successRate: Math.round(successRate * 10) / 10,
    };
  }
}

// Export singleton instance
export const db = new ProductionDatabase();

